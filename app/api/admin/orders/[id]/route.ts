import { auth } from '@/lib/auth';
import AuditLog from '@/lib/models/AuditLog';
import Courier from '@/lib/models/Courier';
import CourierSettings from '@/lib/models/CourierSettings';
import Order from '@/lib/models/Order';
import connectDB from '@/lib/mongodb';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth();
    if (!session || !['admin', 'manager', 'staff'].includes(session.user?.role)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    await connectDB();
    
    const { id } = await context.params;
    const order = await Order.findById(id)
      .populate('customer', 'firstName lastName email phone')
      .populate('items.product', 'name thumbnailImage');
    
    if (!order) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 });
    }

    return NextResponse.json(order);
  } catch (error) {
    console.error('Get order error:', error);
    return NextResponse.json({ error: 'Failed to fetch order' }, { status: 500 });
  }
}

export async function PATCH(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth();
    if (!session || !['admin', 'manager', 'staff'].includes(session.user?.role)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    await connectDB();
    
    const { id } = await context.params;
    const updateData = await request.json();
    
    const oldOrder = await Order.findById(id);
    if (!oldOrder) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 });
    }

    // Update order
    const updatedOrder = await Order.findByIdAndUpdate(
      id,
      {
        ...updateData,
        ...(updateData.orderStatus === 'delivered' && { deliveredAt: new Date() })
      },
      { new: true }
    ).populate('customer').populate('items.product');


    // Auto-generate courier record when order status changes to 'confirmed'
    let courierAutoGenerated = false;
    if (updateData.orderStatus === 'confirmed' && oldOrder.orderStatus !== 'confirmed') {
      try {
        // Check if courier already exists for this order
        const existingCourier = await Courier.findOne({ order: id });
        
        if (!existingCourier) {
          // Get courier settings
          let courierSettings = await CourierSettings.findOne();
          
          if (!courierSettings) {
            courierSettings = await CourierSettings.create({
              senderInfo: {
                name: process.env.NEXT_PUBLIC_SITE_NAME || 'TSR Gallery',
                phone: process.env.NEXT_PUBLIC_CONTACT_PHONE || '+8801234567890',
                address: process.env.NEXT_PUBLIC_CONTACT_ADDRESS || '123 Technology Street',
                division: 'Dhaka',
                district: 'Dhaka',
              },
              deliveryCharges: {
                regularWithinDhaka: 60,
                regularOutsideDhaka: 100,
                expressWithinDhaka: 100,
                expressOutsideDhaka: 150,
                sameDayWithinDhaka: 150,
                fragileHandlingCharge: 20,
              },
              codChargeRate: 1,
              weightBasedCharging: true,
              freeDeliveryThreshold: 1000,
              defaultCourierPartners: ['steadfast'],
            });
          }

          // Generate courier ID
          const courierId = `CR${Date.now().toString().slice(-8)}`;

          if (!updatedOrder) {
            throw new Error('Updated order not found');
          }

          // Calculate parcel details from order items
          const totalWeight = updatedOrder.items?.reduce((sum: number, item: any) => {
            const itemWeight = item.product?.weight || 0.5;
            return sum + itemWeight * item.quantity;
          }, 0) || 0.5;

          const parcelDescription = updatedOrder.items?.map((item: any) => 
            `${item.name} (Qty: ${item.quantity})`
          ).join(', ') || 'Order items';


          // Determine if delivery is within Dhaka
          const isWithinDhaka = updatedOrder.shippingAddress?.city?.toLowerCase().includes('dhaka') || 
                               updatedOrder.shippingAddress?.district?.toLowerCase().includes('dhaka') ||
                               updatedOrder.shippingAddress?.division?.toLowerCase().includes('dhaka');

          // Determine delivery type based on order delivery type
          let deliveryType = 'regular';
          if (updatedOrder.deliveryType === 'express') {
            deliveryType = 'express';
          } else if (updatedOrder.deliveryType === 'same-day') {
            deliveryType = 'express';
          }

          // Calculate delivery charge
          let deliveryCharge = 60;
          if (deliveryType === 'regular') {
            deliveryCharge = isWithinDhaka ? 
              courierSettings.deliveryCharges.regularWithinDhaka : 
              courierSettings.deliveryCharges.regularOutsideDhaka;
          } else if (deliveryType === 'express') {
            deliveryCharge = isWithinDhaka ? 
              courierSettings.deliveryCharges.expressWithinDhaka : 
              courierSettings.deliveryCharges.expressOutsideDhaka;
          }

          // Calculate COD charge
          let codCharge = 0;
          const isCOD = updatedOrder.paymentMethod === 'cod';
          if (isCOD) {
            codCharge = Math.max(10, (updatedOrder.total * courierSettings.codChargeRate) / 100);
          }

          // Create courier record
          const courierData = {
            courierId,
            order: updatedOrder._id,
            sender: {
              name: courierSettings.senderInfo.name,
              phone: courierSettings.senderInfo.phone,
              address: courierSettings.senderInfo.address,
              division: courierSettings.senderInfo.division,
              district: courierSettings.senderInfo.district,
            },
            receiver: {
              name: updatedOrder.shippingAddress?.name || `${updatedOrder.customer?.firstName || ''} ${updatedOrder.customer?.lastName || ''}`.trim() || 'Customer',
              phone: updatedOrder.shippingAddress?.phone || updatedOrder.customer?.phone || '',
              address: updatedOrder.shippingAddress?.street || '',
              city: updatedOrder.shippingAddress?.city || '',
              district: updatedOrder.shippingAddress?.district || '',
              division: updatedOrder.shippingAddress?.division || '',
            },
            parcel: {
              type: deliveryType as 'regular' | 'express' | 'fragile',
              quantity: updatedOrder.items?.reduce((sum: number, item: any) => sum + (item.quantity || 1), 0) || 1,
              weight: Math.max(totalWeight, 0.5),
              value: updatedOrder.total || 0,
              description: parcelDescription,
            },
            isCOD,
            codAmount: isCOD ? updatedOrder.total : 0,
            isFragile: false,
            charges: {
              deliveryCharge,
              codCharge,
              totalCharge: deliveryCharge + codCharge,
            },
            status: 'pending',
            statusHistory: [{
              status: 'pending',
              timestamp: new Date(),
              updatedBy: session.user.id,
              notes: 'Auto-generated courier record (PATCH)'
            }],
            courierPartner: courierSettings.defaultCourierPartners[0] || 'steadfast',
            notes: `Auto-generated from order ${updatedOrder.orderNumber} (via PATCH)`,
          };

          const createdCourier = await Courier.create(courierData);

          courierAutoGenerated = true;

          // Log courier creation
          await AuditLog.create({
            user: session.user.id,
            action: 'CREATE',
            resource: 'Courier',
            resourceId: courierId,
            metadata: { 
              orderId: updatedOrder._id.toString(),
              orderNumber: updatedOrder.orderNumber,
              autoGenerated: true,
              createdVia: 'PATCH'
            }
          });
        }
      } catch (courierError) {
        console.error('Error auto-generating courier (PATCH):', courierError);
        console.error('Courier error stack (PATCH):', courierError instanceof Error ? courierError.stack : 'Unknown error');
      }
    }

    // Log audit for significant changes
    const changes = [];
    if (updateData.orderStatus && updateData.orderStatus !== oldOrder.orderStatus) {
      changes.push({
        field: 'orderStatus',
        oldValue: oldOrder.orderStatus,
        newValue: updateData.orderStatus
      });
    }
    if (updateData.paymentStatus && updateData.paymentStatus !== oldOrder.paymentStatus) {
      changes.push({
        field: 'paymentStatus',
        oldValue: oldOrder.paymentStatus,
        newValue: updateData.paymentStatus
      });
    }

    if (changes.length > 0) {
      await AuditLog.create({
        user: session.user.id,
        action: 'UPDATE',
        resource: 'Order',
        resourceId: id,
        changes,
        metadata: { 
          orderNumber: updatedOrder.orderNumber,
          notes: updateData.notes || ''
        }
      });
    }

    return NextResponse.json({
      ...updatedOrder.toObject(),
      courierAutoGenerated
    });
  } catch (error) {
    console.error('Update order error:', error);
    return NextResponse.json({ error: 'Failed to update order' }, { status: 500 });
  }
}

export async function DELETE(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth();
    if (!session || !['admin', 'manager'].includes(session.user?.role)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    await connectDB();
    
    const { id } = await context.params;
    const order = await Order.findById(id);
    
    if (!order) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 });
    }

    await Order.findByIdAndDelete(id);

    // Log audit
    await AuditLog.create({
      user: session.user.id,
      action: 'DELETE',
      resource: 'Order',
      resourceId: id,
      changes: [],
      metadata: { 
        orderNumber: order.orderNumber,
        reason: 'Manual deletion via admin panel'
      }
    });

    return NextResponse.json({ 
      message: 'Order deleted successfully',
      orderNumber: order.orderNumber
    });
  } catch (error) {
    console.error('Delete order error:', error);
    return NextResponse.json({ error: 'Failed to delete order' }, { status: 500 });
  }
}
